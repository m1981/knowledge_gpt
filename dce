#!/usr/bin/env python3

import json
import subprocess
import os
import sys

# Path to the JSON configuration file
CONFIG_FILE = '.dce.json'

SCRIPT_NAME_INDEX = 0  # Index for script name
SERVICE_ARG_INDEX = 1  # Index for service argument
COMMAND_ARG_INDEX = 2  # Index for command argument
NESTED_ARG_INDEX = 3   # Index for nested argument

def load_config(config_path):
    with open(config_path, 'r') as json_file:
        return json.load(json_file)

def run_command(service, command, env_vars=None):
    if env_vars:
        for key, value in env_vars.items():
            os.environ[key] = value
    subprocess.run(command, shell=True)

def get_user_choice(options, prompt):
    print_available_options(options, prompt)
    choice = input("Enter your choice: ").strip()
    return choice if choice in options else None

def print_available_options(options, title='Available options:'):
    print(title)
    for index, option in enumerate(sorted(options), start=1):
        print(f"{index}. {option}")

def get_user_choice(options, prompt):
    print_available_options(options, prompt)
    while True:
        choice_input = input("Enter your choice (number): ").strip()
        try:
            # Convert to 0-based index; raise ValueError if not a positive int
            choice_index = int(choice_input) - 1
            if choice_index >= 0 and choice_index < len(options):
                # Return the corresponding option
                return sorted(options)[choice_index]
            else:
                print("Choice out of range. Please try again.")
        except ValueError:
            print("Invalid choice. Please enter a number. Try again.")

def get_nested_command_options(command_data, key):
    # Check if the command is nested and get nested options if so
    if isinstance(command_data, dict) and all(isinstance(value, dict) for value in command_data.values()):
        print(f"{key.capitalize()} options:")
        return command_data.keys()
    return []

def main():
    config = load_config(CONFIG_FILE)

    if len(sys.argv) < SERVICE_ARG_INDEX+1 or sys.argv[SERVICE_ARG_INDEX] not in config['services']:
        # No valid service provided as argument, prompt the user
        service_choice = get_user_choice(config['services'], "Select a service:")
        if not service_choice:
            print("No valid service provided.")
            sys.exit(1)
    else:
        service_choice = sys.argv[SERVICE_ARG_INDEX]

    service = config['services'][service_choice]

    if len(sys.argv) < COMMAND_ARG_INDEX+1 or sys.argv[COMMAND_ARG_INDEX] not in service['commands']:
        # No valid command provided as argument, prompt the user
        command_choice = get_user_choice(service['commands'], f"Select a command for {service_choice}:")
        if not command_choice:
            print(f"No valid command provided for {service_choice}.")
            sys.exit(1)
    else:
        command_choice = sys.argv[COMMAND_ARG_INDEX]

    command_data = service['commands'][command_choice]
    env_vars = {}
    command = ""

    # Handle nested command options
    nested_options = get_nested_command_options(command_data, command_choice)
    if nested_options:
        if len(sys.argv) < NESTED_ARG_INDEX+1 or sys.argv[NESTED_ARG_INDEX] not in nested_options:
            nested_choice = get_user_choice(nested_options, f"Select an option for {command_choice}:")
            if not nested_choice:
                print(f"No valid option provided for {command_choice}.")
                sys.exit(1)
        else:
            nested_choice = sys.argv[NESTED_ARG_INDEX]
        env_vars = command_data[nested_choice].get('env', {})
        command = command_data[nested_choice]['command']
    else:
        command = command_data

    full_command = f"docker-compose --env-file {service['env_file']} -f {service['path']}/{command}"
    run_command(service_choice, full_command, env_vars)

if __name__ == "__main__":
    main()
